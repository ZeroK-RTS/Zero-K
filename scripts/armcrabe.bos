//ARM CRABRE SCRIPT BY TA-FOREVER (Sephiroth) (http://www.planetannihilation.com/taforever, http://www.planetannihilation.com/taan)

//linear constant 78643.2 (65536*1.2)

piece base, ground, turret, blight, canon, barrel1, barrel2,
      flare1, flare2, flare3, flare4, flare5, flare6, flare7, rocket, leg1, leg2, leg3, leg4, gflash ;

static-var bMoving, restore_delay, gun_0, bCurled, bCurling, base_speed, nocurl;
	
#define	ANIM_VARIABLE   bMoving
#undef	ANIM_VARIABLE
#define SIG_AIM1	2
#define SIG_AIM2	4
#define SIG_CURL	8
#define SIG_UNCURL	16
#define SMOKEPIECE1 turret
#include "smokeunit.h"
#include "exptype.h"

walkscr()
	{
		SET MAX_SPEED to base_speed;
		WHILE (bMoving)
			{
			IF (bMoving)
				{
				
				TURN leg1 to y-axis <43> SPEED <30>;
				TURN leg1 to y-axis <0> SPEED <30>;
				TURN leg1 to z-axis <0> SPEED <30>;
				//TURN leg1 to z-axis <0> SPEED <30>;
				TURN leg2 to z-axis <0> SPEED <30>;
				TURN leg2 to z-axis <31> SPEED <30>;
				TURN leg3 to y-axis <34> SPEED <30>;
				//TURN leg3 to y-axis <34> SPEED <30>;
				TURN leg3 to z-axis <31> SPEED <30>;
				TURN leg3 to z-axis <0> SPEED <30>;
				TURN leg4 to y-axis <-40> SPEED <30>;
				//TURN leg4 to y-axis <-40> SPEED <30>;
				TURN leg4 to z-axis <-31> SPEED <30>;
				TURN leg4 to z-axis <0> SPEED <30>;
				TURN base to z-axis <2> SPEED <5>;
				SLEEP 200;
				}
			IF (bMoving)
				{
				TURN leg1 to z-axis <39> SPEED <30>;
				TURN leg2 to y-axis <34> SPEED <30>;
				TURN leg2 to z-axis <31> SPEED <30>;
				TURN leg3 to y-axis <0> SPEED <30>;
				TURN leg3 to z-axis <0> SPEED <30>;
				TURN leg4 to y-axis <0> SPEED <30>;
				TURN base to z-axis <-2> SPEED <5>;
				SLEEP 200;
				}
			IF (bMoving)
				{
				TURN leg1 to y-axis <55> SPEED <30>;
				TURN leg1 to z-axis <31> SPEED <30>;
				TURN leg2 to y-axis <34> SPEED <30>;
				TURN leg2 to z-axis <0> SPEED <30>;
				TURN leg3 to z-axis <31> SPEED <30>;
				TURN leg4 to y-axis <0> SPEED <30>;
				TURN leg4 to z-axis <-31> SPEED <30>;
				TURN base to z-axis <2> SPEED <5>;
				SLEEP 200;
				}
			TURN leg1 to y-axis <46> SPEED <30>;
			TURN leg1 to z-axis <0> SPEED <30>;
			TURN leg2 to y-axis <0> SPEED <30>;
			TURN leg2 to z-axis <0> SPEED <30>;
			TURN leg3 to y-axis <37> SPEED <30>;
			TURN leg3 to z-axis <34> SPEED <30>;
			TURN leg4 to y-axis <-40> SPEED <30>;
			TURN leg4 to z-axis <-31> SPEED <30>;
			//TURN base to z-axis <-2> SPEED <5>;
			SLEEP 200;
			}
	}

Curl()
{
	if (nocurl == 1 ) {return 0;}
	signal SIG_UNCURL;
	set-signal-mask SIG_CURL;
	
	SET MAX_SPEED to <0.1>;
	
	bCurling = TRUE;
	
	turn leg1 to y-axis <45> speed <35>;
	turn leg4 to y-axis <-45> speed <35>;
	
	
	turn leg2 to y-axis <-45> speed <35>;
	turn leg3 to y-axis <45> speed <35>;
	
	
	turn leg1 to z-axis <-45> speed <35>;
	turn leg4 to z-axis <45> speed <35>;
	
	
	// raise legs (back)
	turn leg2 to z-axis <-40> speed <35>;
	turn leg3 to z-axis <40> speed <35>;

	
	TURN leg2 to x-axis <-180> speed <105>;
	TURN leg3 to x-axis <-180> speed <105>;
	
	TURN leg1 to x-axis <-180> speed <95>;	
	TURN leg4 to x-axis <-180> speed <95>;


	move canon to y-axis [4] speed [1];
	move base to y-axis [-2] speed [1];
	move base to z-axis [-2] speed [1];

    wait-for-turn leg1 around x-axis;
    wait-for-turn leg2 around x-axis;
    wait-for-turn leg3 around x-axis;
    wait-for-turn leg4 around x-axis;
        
    wait-for-turn leg1 around y-axis;
    wait-for-turn leg2 around y-axis;
    wait-for-turn leg3 around y-axis;
    wait-for-turn leg4 around y-axis;
        
    wait-for-turn leg1 around z-axis;
    wait-for-turn leg2 around z-axis;
    wait-for-turn leg3 around z-axis;
    wait-for-turn leg4 around z-axis;    
	
   	bCurled = TRUE;
   	bCurling = FALSE;

}
Uncurl()
{
	signal SIG_CURL; 
	set-signal-mask SIG_UNCURL;
	
	bCurled = FALSE;
	bCurling = TRUE;
	
	
	TURN leg1 to x-axis <0> speed <95>;
	TURN leg2 to x-axis <0> speed <95>;
	TURN leg3 to x-axis <0> speed <95>;
	TURN leg4 to x-axis <0> speed <95>;
	
	turn leg1 to y-axis <0> speed <35>;
	turn leg2 to y-axis <0> speed <35>;
	turn leg3 to y-axis <0> speed <35>;
	turn leg4 to y-axis <0> speed <35>;
	
	turn leg1 to z-axis <0> speed <25>;
	turn leg2 to z-axis <0> speed <25>;
	turn leg3 to z-axis <0> speed <25>;
	turn leg4 to z-axis <0> speed <25>;
	
		
	move canon to y-axis [0] speed [1];
	move base to y-axis [0] speed [1];
	move base to z-axis [0] speed [1];
    
    wait-for-turn leg1 around x-axis;
    wait-for-turn leg2 around x-axis;
    wait-for-turn leg3 around x-axis;
    wait-for-turn leg4 around x-axis;
        
    wait-for-turn leg1 around y-axis;
    wait-for-turn leg2 around y-axis;
    wait-for-turn leg3 around y-axis;
    wait-for-turn leg4 around y-axis;
        
    wait-for-turn leg1 around z-axis;
    wait-for-turn leg2 around z-axis;
    wait-for-turn leg3 around z-axis;
    wait-for-turn leg4 around z-axis;    
	
    SET MAX_SPEED to base_speed;
    bCurling = FALSE;
}

MotionControl(moving, curling, curled)
{
		WHILE ( TRUE )
		{
			moving = bMoving ;
			curling = bCurling;
			curled = bCurled;
			IF (moving && !curling)
			{
				
								
			}
			IF (!moving )
			{
				sleep 100;
				 
				IF (!curled)
				{
								
					START-SCRIPT Curl();
				}
				ELSE
				{
					set ARMORED to TRUE;
				}
			}
			ELSE
			{
				
				IF (curled && !curling)
				{
				
					set ARMORED to FALSE;
					START-SCRIPT Uncurl();
					
				}
				ELSE
				{
					IF (!curling)
					{
						CALL-SCRIPT walkscr();
					}
				}
			}
			
			
			sleep 100;	
		}
}

BlinkingLight()
{
	while( get BUILD_PERCENT_LEFT )
	{
		sleep 3000;
	}
	while( TRUE )
	{
		emit-sfx 1024+2 from blight;
		sleep 2100;
	}
}

CurlDelay()	//workaround for crabe getting stuck in fac
{
	while( get BUILD_PERCENT_LEFT )
	{
		sleep 1000;
	}
	sleep 3000;
	nocurl = 0;
}

Create()
{
	base_speed = GET MAX_SPEED;
	set ARMORED to FALSE;
	dont-cache turret;
	hide flare1;
	hide flare2;
	hide flare3;
	hide flare4;
	hide flare5;
	hide flare6;
	hide flare7;
	
	nocurl = 1;
	gun_0 = 0;
	bMoving = FALSE;
	bCurled = FALSE;
	bCurling = FALSE;
	START-SCRIPT MotionControl();
	START-SCRIPT SmokeUnit();
	//START-SCRIPT BlinkingLight();
	START-SCRIPT CurlDelay();
}

StartMoving()
	{
	bMoving = TRUE;
	}

StopMoving()
	{
	bMoving = FALSE;
	}


BlockShot1(unit, block) {
	if (bCurling || (!bMoving && !bCurled)) block = 1;
}
	
	
RockUnit(anglex,anglez)
	{
	turn base to x-axis anglex speed <50.000000>;
	turn base to z-axis anglez speed <50.000000>;
	wait-for-turn base around z-axis;
	wait-for-turn base around x-axis;
	turn base to z-axis <0.000000> speed <20.000000>;
	turn base to x-axis <0.000000> speed <20.000000>;
	return (0);
	}

RestoreAfterDelay1()
	{
	sleep 3000;
	turn turret to y-axis <0> speed <70>;
	turn canon to x-axis <0> speed <50>;
	}

RestoreAfterDelay2()
	{
	sleep 3000;
	turn rocket to y-axis <0> speed <70>;
	turn rocket to x-axis <0> speed <50>;
	}

AimPrimary(heading,pitch)
{
	signal SIG_AIM1;
	set-signal-mask SIG_AIM1;
	turn turret to y-axis heading speed <70>;
	turn canon to x-axis <0> - pitch speed <50>;
	wait-for-turn turret around y-axis;
	wait-for-turn canon around x-axis;
	start-script RestoreAfterDelay1();
	return(TRUE);
}

AimSecondary(heading,pitch)
{
	signal SIG_AIM2;
	set-signal-mask SIG_AIM2;
	turn rocket to y-axis heading speed <190>;
	turn rocket to x-axis <0> - pitch speed <150>;
	wait-for-turn rocket around y-axis;
	wait-for-turn rocket around x-axis;
	start-script RestoreAfterDelay2();
	return(TRUE);
}

FirePrimary()
{
	move barrel1 to z-axis [-1] now;
	emit-sfx 1024+0 from flare1;	
	emit-sfx 1024+1 from gflash;
	//show flare1;
	//sleep 150;
	//hide flare1;
	move barrel2 to z-axis [-1] now;
	wait-for-move barrel2 along z-axis;
	move barrel1 to z-axis [0] speed [3];
	move barrel2 to z-axis [0] speed [3];
}

FireSecondary()
{
	if (gun_0 == 0 )
		{
		show flare2;
		show flare5;
		sleep 150;
		hide flare2;
		hide flare5;
		}
	if (gun_0 == 1 )
		{
		show flare3;
		show flare6;
		sleep 150;
		hide flare3;
		hide flare6;
		}
	if (gun_0 == 2 )
		{
		show flare4;
		show flare7;
		sleep 150;
		hide flare4;
		hide flare7;
		}
	++gun_0;
	if (gun_0 == 3 )
		{
		gun_0 = 0;
		}
}

AimFromPrimary(piecenum)
{
	piecenum=turret;
}

QueryPrimary(piecenum)
{
	piecenum=flare1;
}

AimFromSecondary(piecenum)
{
	piecenum=rocket;
}

QuerySecondary(piecenum)
{
	if (gun_0==0) 
		{
		piecenum=flare2; 
		}
	if (gun_0==1) 
		{
		piecenum=flare3; 
		}
	if (gun_0==2) 
		{
		piecenum=flare4; 
		}
}

SweetSpot(piecenum)
{
		piecenum = turret;
}
Killed(severity,corpsetype)
{
	hide flare1;
	hide flare2;
	hide flare3;
	hide flare4;
	hide flare5;
	hide flare6;
	hide flare7;
	IF (severity <= 25 )
		{
		corpsetype = 1 ;
		EXPLODE base 	type  	BITMAPONLY | BITMAP1;
		explode leg4 	type 	SHATTER | BITMAP3;
		RETURN ( 0 );
		}
	IF (severity <= 50 )
		{
		corpsetype = 1 ;
		EXPLODE base 	type  	BITMAPONLY | BITMAP1;
		explode leg1 	type 	BITMAPONLY | BITMAP2;
		explode leg3 	type 	BITMAPONLY | BITMAP3;
		explode turret 	type 	FALL | SMOKE | EXPLODE_ON_HIT | BITMAP3;		
		
		RETURN ( 0 );
		}
	IF (severity <= 99 )
		{
		corpsetype = 2 ;
		EXPLODE base 	type  	BITMAPONLY | BITMAP1;
		explode leg1 	type 	BITMAPONLY | BITMAP2;
		explode leg3 	type 	BITMAPONLY | BITMAP3;
		explode barrel2 type 	FALL | SMOKE | EXPLODE_ON_HIT | BITMAP3;
		explode turret 	type 	SHATTER | EXPLODE_ON_HIT | BITMAP1;
		RETURN ( 0 );
		}
	corpsetype = 3 ;
	EXPLODE base 	type  	BITMAPONLY | BITMAP1;
	explode leg1 	type 	BITMAPONLY | BITMAP2;
	explode leg3 	type 	BITMAPONLY | BITMAP3;
	explode barrel2 type 	FALL | SMOKE | EXPLODE_ON_HIT | BITMAP3;
	explode turret 	type 	SHATTER | EXPLODE_ON_HIT | BITMAP1;
}
